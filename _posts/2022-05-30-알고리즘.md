---
layout: post
title:  "그외 알고리즘"
date:   2022-05-30 10:30:30 +0900
categories: JavaScript
---

알고리즘 문제 해결 능력을 기르는 것은 결국 계속해서 문제를 풀어보면서 눈에 익히는 방법밖에 없는 것 같다.  
코딩 테스트를 치고 좀 많이 좌절했는데 내가 알고리즘 문제 풀이에 익숙하지 않아서라는 것을 깨달았다.  
뭐든지 요령을 금방 익히고 아니고의 차이는 있어도 처음부터 잘하는 사람은 없다.  
걷는 것도 아기 때는 엄청 넘어지면서 배웠는데 지금은 뛰기까지 한다.  
그러니까 일희일비하지 말고 그냥 꾸준하게 하다 보면 나도 어느새 익숙하게 알고리즘 문제를 풀 수 있을 것이다.  

## 재귀(recursion)
- 어떤 문제를 작은 단위의 동일한 문제들로 나누어 해결하는 방법으로 함수 자기 자신을 호출하는 것이 특징
  ```js
  var recursionFunc = function(someParam){
    recursionFunc(someParam);
  };
  ```
- 별다른 조건 없이 실행하면 무한 루프에 빠질 수 있다. 그것을 막기 위해 재귀 호출을 멈추는 중단점, 베이스 케이스(base case)가 필요하다.
- 피보나치 수열
  ```js
  // 재귀 호출을 사용한 경우
  function fibonacci(num){
    if(num === 1 || num === 2){
      return 1;
    }
    return fibonacci(num-1)+fibonacci(num-2);
  }
  //재귀 호출을 사용하지 않은 경우
  function fib(num){
    let n1 = 1, n2 = 1, n = 1;
    for(let i = 3; i < num; i++){
      n = n1 + n2;
      n1 = n2;
      n2 = n;
    }
    return n;
  }
  ```
  - 재귀 호출을 사용하지 않은 경우가 더 빠르지만 재귀 호출을 사용한 코드가 더 명료하게 이해되고 코드의 양도 줄어든다.

## 동적 프로그래밍(Dynamic Programming)
- 복잡한 문제를 작은 하위 문제들로 나누어 푸는 최적화 기법
- 동적 프로그래밍 순서
  1. 하위 문제들을 정의
  2. 하위 문제들을 풀기 위한 재귀를 구현
  3. 베이스 케이스 찾기

## 욕심쟁이 알고리즘(Greedy Algorithm)
- 전역 최적해(전체적으로 최적인 해)를 찾기 위해 각 단계마다 지역 최적해(현 단계에서의 최적해)를 선택해 문제를 해결하는 방법
- 동적 알고리즘보다 간단하고 빠르긴 하지만 항상 최적의 답을 내놓지는 못함
- 평균적으로 봐서는 수행 시간에 비해 만족할 만한 결과를 내놓음